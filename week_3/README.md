# Collaborative filtering

## 專案目的
建立使用user_based，item_based，與套件進行collaborative filtering的推薦系統

## 使用工具
sklearn, pandas, surprise, yellowbrick

## 資料處理

1. 只使用Beauty personal care的類別資料
2. 將商品的title與description做為text資料，觀察此欄位的n-gram資料並設定停用詞，篩選出產品關鍵字
3. 商品包含產品關鍵字即視為此商品的類別
4. 針對未包含產品關鍵字的商品，使用kmeans搭配elbow method與實際觀察，標上商品類別
## 推薦方法
在此，三種推薦方法在消費者無消費紀錄時皆使用相同的冷啟動規則，方式如下：
* 商品類別為[2, 26, 28]的評論做為訓練資料
* 使用四個時間點['2018-07-01','2018-05-01', '2018-01-01', '2016-01-01']後的訓練資料,計算商品評論分數大於4的評論總數量

三種推薦方法在消費者有消費紀錄時使用以下規則:
* user_based:
    * 藉由課程提供程式碼尋找到相似消費者
    * 蒐集此消費者所有買過的商品做為參考商品
    * 將參考商品中,類別前三多的類,做為目標類別
    * 統計目標類別中商品評論大於4的評論總數量
    * 將評論數前k多的商品做為推薦商品
* item_based:
    * 藉由課程提供程式碼尋找到相似商品
    * 統計相似商品中,類別前三多的類,做為目標類別
    * 統計目標類別中商品評論大於4的評論總數量
    * 將評論數前k多的商品做為推薦商品
* surprise
    * 使用KNNWithMeans做為分類演算法
    * 使用item_base, user_base與不同距離計算推薦結果
## 結果

![](https://i.imgur.com/Disc5Ev.png)

由上圖可見user_based與surprise方法幾乎無法對原本的rule_base推薦產生正面影響
原因是因為user_based方法計算矩陣後，只能對３位使用者進行推薦，surprise方法則是根據不同時間資料對2, 2, 4, 11位使用者推薦了商品，這兩種方法影響的使用者數量都太少了，感覺不出來實際效能的差別，而在item_based方法的部分推薦的使用者較多，總共對32位使用者推薦了商品,但推薦商品的準確度不夠高，因此recall還低於本來的baseline

此次練習對user_based與item_based方法的效能差異感受很明顯，user_based方法計算時間明顯多很多，也因為記憶體的關係，user_based的方法要限制矩陣的使用者數量，導致最後產生推薦的人數只有3人，明顯比item_based方法劣勢一些，可以檢討的是此次推薦規則並沒有很好，因為item_based方法中並沒有產生不錯的推薦結果，甚至還較差，還有進步的空間。

p.s. 本機開發使用windows，與colab不同，因此腳本結果略有差異
